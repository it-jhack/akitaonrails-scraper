
Ola Bini é um colaboradores mais ativos do JRuby. É um programador jovem (tem seus 24 anos ou algo assim) mas conhece muito bem os detalhes da arte da programação. Apreciador de Lisp e inteligência artificial, é exatamente o tipo de artista que sabe apreciar a Boa Programação. Em luz dos recentes transtornos sobre a controvérsia Twitter, ele escreveu este divertido artigo que traduzo mais abaixo.
Diferente dos pseudo-gurus que continuamente apenas gostam de falar mal dos outros e jogar indiretas. Lembrem-se de uma coisa: um bom profissional não precisa falar mal dos outros como forma de parecer que está correto. Um bom profissional convence que o que ele acredita é bom por méritos próprios.
Outro bom exemplo? Avi Bryant. Ele teria todos os motivos do mundo para ser apenas mais um xiita, falar mal de Ruby, falar mal de Python, falar mal de Perl. Mas ele também é um artista. Ele acredita na tecnologia que desenvolve. Prova disso foi o que eu noticiei semana passada: em vez de cruzar os braços, foi ajudar a implementar Ruby sobre uma virtual machine Smalltalk. Não só isso, mas quando eu o entrevistei, ele disse abertamente que o carro-chefe do framework Seaside, o produto DabbleDB, também utiliza códigos em Ruby e Python. Bons programadores escolhem boas ferramentas para trabalhar. Xiitas precisam que os outros percam para que eles ganhem.
No longo prazo, adivinhem o que funciona? Bom, vamos à tradução:


Apenas adicione Escalabilidade!
(Para proteger os inocentes, todos os nomes das linguagens de programação foram modificadas. Qualquer semelhança com nomes existentes é puramente para efeito dramático.)
Ouvi muitas vezes que LRM não escala. As pessoas vivem me dizendo isso em várias circunstâncias diferentes. Eles me dizem que linguagens como Deep Throttle e Moulder escalam mas LRM não. Mesmo a linguagem Scally escala – o que é visível pelo nome, eu acho. Então por que o LRM não tem essa funcionalidade?
Já que eu gosto de LRM, e realmente não quero voltar nem para Deep Throttle ou Moulder, decidi adicionar escalabilidade ao LRM. Quero dizer, quão difícil poder se isso se todas essas outras linguagens têm? Eu implementei linguagens antes, então este deve ser o caso apenas de encontrar a implementação correta da funcionalidade, e transplantar para a base de código do LRM, e então fornecer um patch para a mailing list.
Já que eu sabia que LRM não tinha escalabilidade, decidi investigar outras linguagens que tem. Eu comecei com a linguagem original, aquela que as pessoas usam para escrever sistemas operacionais. Obviamente uma linguagem como Deep Throttle tem escalabilidade. Então comecei a ler os livros, procurando pela sintaxe. Mas eu não achei em lugar algum. O que eu estava perdendo? Será que existe algum elemento sintático obscuro que não estava documentado, que fornece a escalabilidade? Ou estaria escondido em algum lugar? Talvez os ponteiros na realidade sejam outra palavra para escalabilidade? Mas não, parece que não é isso. Decidi abrir o GDPC, o GNU Deep Throttle Compiler, e ver se esse negócio de escalabilidade na realidade é algo que o compilador faz automaticamente para você – parecido com alocação de registros. Mas não encontrei nenhuma alocação de escalabilidade. Havia várias coisas legais ali, mas tudo ali eram apenas traduções mundanas de Deep Throttle para código de máquina.
Me sentindo muito deprimido, virei minhas atenções ao Moulder. Vou assumir que todos vocês conhecem essa linguagem – é usada em várias partes do mundo e fornece um monte de recursos avançados como garbage collection, uma máquina virtual, e sim – escalabilidade! Claro, é onde isso deveria estar. Talvez Deep Throttle tenha escondido a funcionalidade em algum lugar obscuro, mas eu tinha certeza que Moulder tornaria isso mais fácil de achar. Comecei olhando a sintaxe novamente, olhando o que se podia fazer com a linguagem. Interessante, Moulder é uma linguagem realmente pequena, quando você a entende. É pequena mas você precisa dizer muitas coisas para conseguir fazer qualquer coisa. Eu não consegui achar a sintaxe para escalabilidade, então comecei a pensar em outras idéias. Talvez todas essas palavras extras “protected final static Foo” seriam realmente necessárias. Talvez a escalabilidade aconteça no espaço entre as palavras, ou em alguma estranha interação entre elas? A única maneira de descobrir seria abrir o compilador e olhar o que acontece. Nesse caso até que foi fácil, porque o compilador fazia ainda menos que o do Deep Throttle. Francamente, o compilador do Moulder apenas solta alguns bytecodes. Não havia nenhum tipo de escalabilidade em linha no compilador do Moulder.
Vê onde estou indo? Certo, eu tive que investigar os bytecodes que o Moulder usa. Onde está esse bytecode precioso de escalabilidade? Eu presumo que se chamaria invoke_scaling ou talvez ldscaled. Mas nada. Não havia bytecode de escalabilidade. Todos os bytecodes existentes faziam as mesmas coisas mundanas que eu sei que o LRM sabe fazer também. Eu estava me sentindo pronto para desistir, mas eu tive uma última grande idéia. Scally é famoso por ser uma linguagem que escala. Seus criadores até deram esse nome por causa disso. Então, se ambos Moulder e Scally tem escalabilidade, talvez esteja em algum lugar na gigantesca biblioteca padrão do Moulder?
Mas adivinhe? Eu não encontrei. Ainda não encontrei ninguém que sabe como implementar escalabilidade em uma linguagem, então acho que LRM nunca a terá … Alguém se habilita para me iluminar, por favor me envie um e-mail detalhado com uma implementação de Escalabilidade. Realmente sinto a necessidade de saber como essa coisa funciona.
tags: obsolete translation

